### 前言
学习一种新的数据结构：线段树。 线段树， 曾经我觉得这个方法很ac, 但是看着大佬的帖子，"某某题可以线段树解"， 我不禁好奇,"线段树是什么？" 
### 线段树 (Segment Tree) 介绍

**线段树（Segment Tree）是一种树形结构的数据结构。**

常用于处理区间查询（例如求和、最小值、最大值等）和区间修改（例如区间加法、区间赋值等）问题。它能够在对数组进行区间操作时，提供高效的时间复杂度，通常为 **O(log n)**。

线段树可以应用于很多问题，特别是需要处理动态区间查询和修改的情况，比如：
- 区间求和
- 区间最小值/最大值查询
- 区间更新（加法、赋值等）

### 基本思想

线段树将一个数组分割成若干个区间，并以树形结构存储每个区间的信息。每个节点表示一个区间（或区间的一部分），树的叶子节点表示数组的单个元素。

通过这个结构，我们可以在对一个区间进行查询或修改时，通过递归或迭代的方式快速合并区间结果。

### 线段树的结构

- **叶节点**：每个叶子节点表示数组中的一个元素，通常是数组的某个元素值。
- **内部节点**：每个内部节点表示某个区间的合并结果，通常是区间内元素的某种运算结果（例如求和、最小值、最大值等）。

### 操作

1. **构建线段树**：
   - 初始化时，首先将数组构建成一颗树，树的高度为 **O(log n)**，每个节点表示一个区间的值。
   - 从叶子节点开始，逐层向上合并，构建内部节点。

2. **区间查询**：
   - 给定一个区间 `[l, r]`，通过树结构进行查询。通过判断当前节点的区间是否完全包含、部分包含或完全不包含查询区间，选择性地查询左右子树，直到叶节点。
   - 查询时间复杂度为 **O(log n)**。

3. **区间更新**：
   - 给定一个区间，更新该区间的值。线段树通过逐层向下更新区间内的元素，并及时更新父节点的值。更新操作的时间复杂度也是 **O(log n)**。

### 线段树的基本操作时间复杂度

- **构建线段树**：O(n)
- **查询区间信息**（如区间和、最小值、最大值等）：O(log n)
- **区间更新**：O(log n)

### 线段树的代码实现 (C++)

以下是一个简单的线段树实现示例，支持区间求和查询和单点更新。

```cpp
#include <iostream>
#include <vector>
using namespace std;

class SegmentTree {
private:
    vector<int> tree;  // 存储线段树
    int n;  // 数组大小

    // 构建线段树
    void build(const vector<int>& arr, int node, int start, int end) {
        if (start == end) {
            tree[node] = arr[start];  // 叶子节点直接赋值
        } else {
            int mid = (start + end) / 2;
            int leftChild = 2 * node + 1;
            int rightChild = 2 * node + 2;
            
            // 递归构建左右子树
            build(arr, leftChild, start, mid);
            build(arr, rightChild, mid + 1, end);
            
            // 合并左右子树的结果（这里以区间和为例）
            tree[node] = tree[leftChild] + tree[rightChild];
        }
    }

    // 查询区间 [L, R] 的和
    int query(int node, int start, int end, int L, int R) {
        if (R < start || end < L) {
            return 0;  // 不在查询区间内，返回 0
        }
        if (L <= start && end <= R) {
            return tree[node];  // 完全在查询区间内，返回该节点值
        }
        
        int mid = (start + end) / 2;
        int leftChild = 2 * node + 1;
        int rightChild = 2 * node + 2;
        
        // 部分重叠，查询左右子树
        int leftResult = query(leftChild, start, mid, L, R);
        int rightResult = query(rightChild, mid + 1, end, L, R);
        
        return leftResult + rightResult;  // 合并结果
    }

    // 更新单点数据，更新索引 idx 处的值为 value
    void update(int node, int start, int end, int idx, int value) {
        if (start == end) {
            tree[node] = value;  // 叶子节点更新值
        } else {
            int mid = (start + end) / 2;
            int leftChild = 2 * node + 1;
            int rightChild = 2 * node + 2;
            
            // 更新到左子树或右子树
            if (start <= idx && idx <= mid) {
                update(leftChild, start, mid, idx, value);
            } else {
                update(rightChild, mid + 1, end, idx, value);
            }
            
            // 更新当前节点的值
            tree[node] = tree[leftChild] + tree[rightChild];
        }
    }

public:
    // 构造函数
    SegmentTree(const vector<int>& arr) {
        n = arr.size();
        tree.resize(4 * n);  // 线段树的大小为 4n
        build(arr, 0, 0, n - 1);  // 从根节点开始构建线段树
    }

    // 查询区间 [L, R] 的和
    int query(int L, int R) {
        return query(0, 0, n - 1, L, R);
    }

    // 更新索引 idx 处的值为 value
    void update(int idx, int value) {
        update(0, 0, n - 1, idx, value);
    }
};

int main() {
    vector<int> arr = {1, 3, 5, 7, 9, 11};
    SegmentTree segTree(arr);
    
    cout << "Sum of range [1, 3]: " << segTree.query(1, 3) << endl;  // Output: 15 (3 + 5 + 7)
    
    segTree.update(1, 10);  // Update index 1's value to 10
    
    cout << "Sum of range [1, 3] after update: " << segTree.query(1, 3) << endl;  // Output: 22 (10 + 5 + 7)
    
    return 0;
}
```

### 代码解释

1. **`build` 函数**：递归构建线段树，叶子节点对应数组元素，内部节点存储其左右子节点的和（可以根据需要修改成最小值、最大值等）。
2. **`query` 函数**：递归查询区间和。当查询的区间与当前节点的区间完全重叠时，返回当前节点的值；当查询区间与当前节点的区间不重叠时，返回 0；否则递归查询左右子树。
3. **`update` 函数**：递归更新指定位置的值。如果更新的是叶子节点，则直接修改值；如果是内部节点，则递归更新其左右子树，并在返回时更新当前节点的值。

### 线段树的应用场景

- **区间求和**：线段树常用于动态求区间和，特别是在需要频繁修改数据的情况下。
- **区间最小值/最大值**：通过修改线段树的合并逻辑，可以很容易地支持区间查询最小值或最大值。
- **区间加法**：如果需要对一个区间内的所有元素加上一个常数，可以通过修改线段树的合并和更新逻辑来实现。
- **动态查询和更新**：当数组频繁变化时，线段树提供了一个高效的查询和更新方式。

线段树的存储数组需要开辟 **4n** 的空间，这主要是为了保证在构建线段树时，能够处理树的所有节点，特别是在一些极端情况下，树的深度和节点数可能超出初步估算的大小。下面解释为什么需要 `4 * n` 的大小。

### 1. **树的结构和节点数量**

线段树的结构类似于二叉树，因此它的节点数与树的高度相关。对于一个包含 `n` 个元素的数组，我们需要构建一个包含 `n` 个元素区间信息的树，叶子节点代表数组的每个元素，内部节点则表示各个区间的合并结果。

- 线段树的叶子节点数量就是数组的大小 `n`，即 `n` 个叶子节点对应着数组中的 `n` 个元素。
- 线段树的高度是 **O(log n)**，因为每个内部节点有两个子节点，树的深度大约为对数级别。对于一个包含 `n` 个元素的线段树，最大高度大约是 `log(n)`。

#### 节点数量估算

- 叶子节点的数量是 `n`。
- 除了叶子节点之外，还有很多内部节点。每一层都会有一些额外的节点，根节点是第 1 层，下一层是 2 个节点，再下一层是 4 个节点，以此类推。

因此，整个树的节点数量大约是 `2 * n - 1` 个。这个数量远小于 `4 * n`，但是我们需要给每个节点分配一定的空间。

### 2. **为什么需要开 `4 * n` 空间？**

1. **保留足够的空间**：在构建线段树时，最坏的情况下树的内部节点数（包括叶节点）将接近 `2 * n`，但是为了防止由于不规则的分割（尤其在树的构建中存在极端情况）导致内存溢出，通常需要开辟 `4 * n` 的空间。这个空间足够大以保证任何情况下都能安全存储整个线段树。

2. **保证树的完全二叉结构**：
   - 对于一个包含 `n` 个叶子节点的完全二叉树，其高度为 `log(n)`。
   - 但如果我们把该树表示为一个数组，在数组中存储节点时需要为每个子节点和每个父节点保留足够的空间。由于线段树是一个完全二叉树，节点的总数可能接近 `2 * n`，但实际的空间分配要更宽松一些。
   - 对于树的节点编号，我们可以看到在极端情况下，如果没有空间保证，可能导致树结构不完全。为了避免这种情况，预分配一个 `4 * n` 的大小可以确保我们在任何情况下都有足够的空间来存储所有节点。

3. **树的存储结构**：
   - 假设线段树是一个完全二叉树，对于一个 `n` 个元素的线段树，存储空间通常需要比 `n` 大。树的内部结构会使得节点数接近 `2 * n`，而 `4 * n` 是一个上界，足够覆盖所有情况下的需求。
   - 事实上，通过将每个节点的下标映射到数组中，能够有效地管理这些节点。以 `4 * n` 的大小来存储线段树，可以确保每个节点都有足够的空间，并避免在递归查询和更新时由于树的深度导致空间不足的情况。

### 3. **具体的空间需求**

- 对于一个数组大小为 `n` 的线段树，叶子节点直接映射到数组的元素，因此需要 `n` 个位置来存储。
- 内部节点的数量大约是 `2n - 1`，但是每个节点存储的信息可能是父节点与子节点合并的信息（比如区间和、区间最小值等）。
- 为了避免空间不足，通常将存储数组的大小设置为 `4 * n`。这样，即使在极端情况下（比如树结构不对称），也能够保证不会越界。

### 4. **总结**

线段树数组开辟 **4n** 的空间是为了保证能够安全存储线段树的所有节点，避免在构建和操作过程中出现空间不足的情况。实际的树节点数可能少于 `4 * n`，但为了解决一些极端情况（比如树的深度不均衡或者存储方式的需要），开辟一个稍微多一些的空间（`4 * n`）是必要的。