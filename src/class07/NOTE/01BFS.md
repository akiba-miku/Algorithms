### 01BFS

适用条件: 图中所有边的权重只有0和1两种值， 求源点到目标点的最短距离
时间复杂度:$O(V+E)$。

传统的BFS求解最短路径适用等权图和无权图， 应用了队列和哈希集合。
01BFS， 只需要双端队列。 

从算法的相似度， 它比较像Dijsktra算法， 但与小根堆优化的DJ算法不同， 由于01BFS只有两种权值0和1， 因此用双端队列替换优先队列得到了更高的效率。

----


### 算法流程
1. 需要distance数组， distance[i]含义:表示从源点到i点的最短距离， 初始所有点的distance无限大。
2. 初始化双端队列， `src`源点进入双端队列。 distance[src] = 0;
3. 处理双端队列， 双端队列从头部弹出x：1. 如果x是终点dest， 那么直接返回distance[x]表示源点src到目标点dest。 2. 如果1情况不满足， 那么遍历x的所有边， 假设它去往y点， 边附带权值为w。 *如果distance[y] > distacnce[x] + w, 这句话描述的是如果x通过带权值w的边 到达y比先前x到y的整个权值小， 那么更新`distance[y] = distacne[x] + w`, 反之则忽略此边。*， 另外，更新的同时y点要根据`x->y`的权值选择不同的开口进入双端队列。`w=0,则y点从头部进入;w=1，则y点从尾部进入。`
4. 重复3的过程， 直至双端队列为空。
   


---


### - [使网格图至少有一条有效路径的最小代价](https://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/)->LC:2069


### 正确性证明和经典BFS的最短路区别