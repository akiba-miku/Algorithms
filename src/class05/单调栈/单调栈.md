### 单调栈（Monotonic Stack）模板

单调栈是一种特殊的栈结构，它本质是一种严格递增或者递减关系的栈结构
通常用于解决涉及数组中元素的相对顺序或寻找特定关系（如下一个更大元素）的问题。通过维护栈中的元素保持单调（递增或递减），单调栈能够高效地在**线性时间复杂度**下解决许多经典问题。

---

### 单调栈的基本概念

1. **定义**：
   - **单调递增栈**：栈中的元素从栈底到栈顶按递增顺序排列。
   - **单调递减栈**：栈中的元素从栈底到栈顶按递减顺序排列。

2. **用途**：
   - 寻找数组中每个元素的下一个更大/更小的元素。
   - 解决矩形面积、股票价格等问题。
   - 处理区间查询与滑动窗口等问题。

---

### 单调栈的基本操作流程

1. **初始化**：
   - 创建一个空栈，用于存储数组元素的索引或值。

2. **遍历数组**：
   - 对于数组中的每个元素，执行以下操作：
     - **维护单调性**：
       - 根据需要保持栈的单调性（递增或递减），通过不断弹出不符合单调性的栈顶元素。
     - **处理弹出元素**：
       - 弹出的元素通常与当前元素形成某种关系（如当前元素是弹出元素的下一个更小元素）。
     - **入栈**：
       - 将当前元素的索引或值压入栈中。

3. **清算阶段**：
   - 遍历结束后，可能仍有元素留在栈中，需根据问题需求处理这些元素。

4. **结果处理**：
   - 根据弹出时记录的信息，构建所需的结果，如左右最近小于元素的位置。

---

### 单调栈的模板代码

以下是一个通用的单调栈模板，用于寻找数组中每个元素的左右最近小于元素的位置。该模板可以根据需要调整为寻找更大元素或其他关系。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(false);
    cin.tie(NULL);

    int n;
    cin >> n;
    vector<int> arr(n);
    for(auto &x : arr) cin >> x;

    // 初始化结果向量，存储每个元素的左侧和右侧最近小于元素的索引
    vector<pair<int, int>> ans(n, {-1, -1});

    // 使用单调栈，存储索引
    vector<int> stack_indices;

    // 遍历数组，寻找右侧最近小于元素
    for(int i = 0; i < n; ++i){
        while(!stack_indices.empty() && arr[stack_indices.back()] >= arr[i]){
            int cur = stack_indices.back();
            stack_indices.pop_back();
            // 右侧最近小于元素的位置是当前索引i
            ans[cur].second = i;
            // 左侧最近小于元素的位置是栈的新顶元素
            ans[cur].first = stack_indices.empty() ? -1 : stack_indices.back();
        }
        // 将当前索引压入栈
        stack_indices.push_back(i);
    }

    // 清算阶段，处理栈中剩余元素
    while(!stack_indices.empty()){
        int cur = stack_indices.back();
        stack_indices.pop_back();
        ans[cur].second = -1; // 右侧没有更小元素
        ans[cur].first = stack_indices.empty() ? -1 : stack_indices.back();
    }

    // 修正阶段，处理相同值的情况（根据具体问题需求）
    for(int i = n - 2; i >= 0; --i){
        if(ans[i].second != -1 && arr[i] == arr[ans[i].second]){
            ans[i].second = ans[ans[i].second].second;
        }
    }

    // 输出结果
    for(auto &[L, R] : ans){
        cout << L << " " << R << "\n";
    }

    return 0;
}
```

---

### 模板解释与扩展

1. **使用索引而非值**：
   - 通过存储元素的索引，可以方便地获取元素的左右邻近位置。
   - 允许处理元素之间的关系，而不仅仅是值的比较。

2. **维护单调性**：
   - 例如，若要寻找右侧最近小于元素的位置，使用**单调递增栈**。
   - 当当前元素小于等于栈顶元素时，弹出栈顶元素，直到栈为空或栈顶元素小于当前元素。

3. **记录结果**：
   - 对于每个弹出的元素，当前索引即为其右侧最近小于元素的位置。
   - 栈中的新顶元素即为其左侧最近小于元素的位置。

4. **清算阶段**：
   - 遍历结束后，栈中剩余的元素右侧没有更小元素，设置为`-1`。

5. **修正阶段**（可选，根据具体需求）：
   - 处理数组中存在相同值的情况，确保结果的准确性。

6. **扩展应用**：
   - **寻找右侧最近大于元素**：
     - 将比较符号从`>=`改为`<=`，并适当调整逻辑。
   - **寻找左侧最近大于元素**：
     - 从右向左遍历数组，或在弹出元素时记录左侧位置。
   - **处理区间问题**：
     - 如“柱状图中最大的矩形面积”，利用左右边界确定每个柱子的最大影响范围。

---

### 常见问题与变体

1. **下一更大元素（Next Greater Element, NGE）**：
   - 目标：对于每个元素，找到其右侧第一个更大的元素。
   - 实现：使用单调递减栈。

2. **最大矩形面积**：
   - 目标：在直方图中找到最大的矩形面积。
   - 实现：结合单调栈找到每个柱子的左右边界。

3. **滑动窗口最大值**：
   - 目标：在固定大小的滑动窗口内找到最大值。
   - 实现：使用双端队列（deque）模拟单调队列。

4. **前缀和与单调栈结合问题**：
   - 目标：如在子数组中寻找满足某种条件的最短或最长子数组。
   - 实现：结合前缀和和单调栈维护相关信息。

---

### 性能分析

- **时间复杂度**：O(n)
  - 每个元素最多被压入和弹出栈一次。
- **空间复杂度**：O(n)
  - 主要用于存储栈和结果。

---

### 实战提示

1. **明确问题需求**：
   - 确定需要寻找的关系（如左侧最近小于元素、右侧最近更大元素等）。
   - 决定使用单调递增栈或单调递减栈。

2. **选择合适的数据结构**：
   - 单调栈通常使用`std::vector`或`std::stack`，但`std::vector`更灵活且性能更好。

3. **处理边界条件**：
   - 元素没有满足条件的邻近元素时，需正确设置结果（如`-1`）。
   - 处理数组中重复元素的情况。

4. **优化输入输出**：
   - 对于大规模数据，使用快速IO方法，如`scanf`/`printf`或优化的`cin`/`cout`。

5. **调试与验证**：
   - 使用简单的测试用例验证逻辑。
   - 检查栈操作的正确性和结果的准确性。

---

### 示例问题解析

**问题**：给定一个数组，找到每个元素左右最近小于它的元素的位置，若不存在则为`-1`。

**输入**：
```
5
3 1 2 4 1
```

**输出**：
```
-1 1
-1 4
1 4
2 -1
-1 -1
```

**解释**：
- `3`的左侧没有小于它的元素，右侧第一个小于它的是`1`（索引1）。
- `1`的左侧没有小于它的元素，右侧第一个小于它的是`1`（索引4）。
- `2`的左侧第一个小于它的元素是`1`（索引1），右侧第一个小于它的元素是`1`（索引4）。
- `4`的左侧第一个小于它的元素是`2`（索引2），右侧没有小于它的元素。
- 最后的`1`左右均没有小于它的元素。

---

### 总结

单调栈是一种高效解决数组中元素关系问题的工具。通过维护栈的单调性，能够在O(n)的时间复杂度内找到各种邻近关系，如下一个更大/更小元素、前驱/后继等。掌握单调栈的基本模板和变体，对于应对复杂的算法问题具有重要意义。

### 推荐练习

1. **下一个更大元素**：
   - [LeetCode 496. Next Greater Element I](https://leetcode.com/problems/next-greater-element-i/)
   - [LeetCode 503. Next Greater Element II](https://leetcode.com/problems/next-greater-element-ii/)

2. **最大矩形面积**：
   - [LeetCode 84. Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)

3. **滑动窗口最大值**：
   - [LeetCode 239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)

通过不断练习这些问题，能够进一步巩固对单调栈的理解和应用能力。